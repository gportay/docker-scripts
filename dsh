#!/bin/sh
#
# Copyright (c) 2017 GaÃ«l PORTAY <gael.portay@savoirfairelinux.com>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the MIT License.
#

# Called as program loader (shebang #!/usr/bin/dsh)
__="$_"
if [ "$__" == "$1" ]; then
	exec <"$1"
	shift
	set -- -s "$@"
	exec $0 "$@"
elif [ "$__" == "$2" ]; then
	opts="$1"
	shift
	exec <"$1"
	shift
	set -- $opts -s "$@"
	exec $0 "$@"
fi

set -e

usage() {
	cat <<EOF
Usage: ${0##*/} [OPTIONS] [COMMAND] [ARG...]

Run a shell as user in a new container and bind mount cwd.

Options:
      -c                        Read commands from command-line.
      -i                        Set interactive.
      -s                        Read commands from standard-input.

      -b or --build             Build image.
      -f or --file              Path to the Dockerfile to use.
      -C or --directory DIR     Change to directory dir before doing anything
                                else.
      -q or --quiet             Suppress the build output and print image ID on
                                success.
      -U or --no-user           Disable user substitution (same as --root).
            --root              Run as root.
      -h or --help              Print usage.
EOF
}

docker_build() {
	cat "$1" - <<EOF | docker build $buildopts --tag "$2" -
RUN groupadd --non-unique --gid $GROUPS $USER
RUN useradd  --non-unique --gid $GROUPS --uid $UID --create-home --home-dir /home/$USER --shell $SHELL $USER
EOF
}

opti=false
opts=false
optc=false
build=false
root=false
file="Dockerfile"
directory="."
runopts="--rm"
while [ "$#" -ne 0 ]; do
	if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
		usage
		exit 0
	elif [ "$1" = "-b" ] || [ "$1" = "--build" ]; then
		build=true
	elif [ "$1" = "-f" ] || [ "$1" = "--file" ]; then
		shift
		file="$1"
	elif [ "$1" = "-C" ] || [ "$1" = "--directory" ]; then
		shift
		directory="$1"
	elif [ "$1" = "-q" ] || [ "$1" = "--quiet" ]; then
		buildopts+=" --quiet"
	elif [ "$1" = "-U" ] || [ "$1" = "--no-user" ]; then
		root=true
	elif [ "$1" = "--root" ]; then
		root=true
	elif [ "$1" = "-c" ]; then
		shift
		optc=true
		break
	elif [ "$1" = "-i" ]; then
		opti=true
	elif [ "$1" = "-s" ]; then
		shift
		opts=true
		break
	elif [ "$1" = "--" ]; then
		shift
		break
	else
		break
	fi
	shift
done

cd "$directory"
hash="$(realpath "$file" | sha256sum - | cut -d' ' -f1)"
tag="dsh-$hash"

# Build image if it does not exist
imageid="$(docker images -q "$tag")"
if [ -z "$imageid" ]; then
	build=true
fi

if $build; then
	docker_build "$file" "$tag" >&2
fi

# Set current user privileges
if ! $root; then
	runopts+=" --user $UID:$GROUPS"
fi

# Bind mount current working directory
runopts+=" --volume $PWD:/home/$USER"

# Set interactive
if $opti || $opts || [ "$#" -eq 0 ]; then
	runopts+=" --interactive"

	# Allocate a pseudo-TTY if stdin/stderr are TTY
	if [ -t 0 ] && [ -t 2 ]; then
		runopts+=" --tty"
	fi
fi

# Read command from stdin
# FIXME: pass "$@" insteand of $*
if $opts; then
	set -- $SHELL -c "cd /home/$USER && $SHELL -s $*"
# Run command from arguments
elif $optc; then
	set -- $SHELL -c "cd /home/$USER && $SHELL -c '$*'"
# No command or invalid
else
	set -- $SHELL -c "cd /home/$USER && $SHELL $*"
fi

exec docker run $runopts "$tag" "$@"
